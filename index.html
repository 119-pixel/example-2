<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI 視覺辨識 (相機修復版)</title>
    
    <!-- 引入 TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

    <style>
        body {
            margin: 0;
            background-color: #000;
            font-family: sans-serif;
            overflow: hidden;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        /* 視訊層 */
        #cam-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        video, canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* UI 層 */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header {
            background: rgba(0,0,0,0.6);
            padding: 15px;
            text-align: center;
            font-weight: bold;
            color: #00ffcc;
            pointer-events: auto;
        }

        .footer {
            padding: 20px;
            display: flex;
            justify-content: center;
            pointer-events: auto;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
        }

        /* 啟動按鈕 */
        .btn {
            background: #007aff;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,122,255,0.3);
            pointer-events: auto;
        }

        .btn:disabled { background: #555; color: #aaa; }

        /* 錯誤訊息框 */
        #error-msg {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 59, 48, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
            z-index: 50;
        }
    </style>
</head>
<body>

    <div id="cam-container">
        <!-- 關鍵：playsinline 讓 iOS 不要全螢幕播放 -->
        <video id="webcam" playsinline muted autoplay></video>
        <canvas id="canvas"></canvas>
    </div>

    <div id="ui-layer">
        <div class="header" id="status-text">請點擊下方按鈕啟動</div>
        
        <!-- 錯誤訊息顯示區 -->
        <div id="error-msg"></div>

        <div class="footer">
            <button class="btn" id="btn-action" onclick="initSystem()">載入模型並開啟相機</button>
        </div>
    </div>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status-text');
        const btnAction = document.getElementById('btn-action');
        const errorBox = document.getElementById('error-msg');

        let model = null;
        let isDetecting = false;

        // 1. 系統初始化入口
        async function initSystem() {
            btnAction.disabled = true;
            btnAction.innerText = "正在載入 AI 模型...";
            
            try {
                // A. 載入模型
                if (!model) {
                    statusText.innerText = "下載 AI 模型中 (約 2-5MB)...";
                    // 使用 lite_mobilenet_v2 速度更快
                    model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
                }

                // B. 啟動相機 (這是您要求的「之前的方法」)
                statusText.innerText = "正在請求相機權限...";
                await startCamera();

                // C. 開始偵測
                btnAction.style.display = 'none'; // 成功後隱藏按鈕
                statusText.innerText = "AI 辨識中";
                
                resizeCanvas();
                detectFrame();
                
            } catch (err) {
                console.error(err);
                showError("啟動失敗：" + err.message + "<br><br>提示：請確認網址是 https 或 localhost，直接開啟檔案通常會被瀏覽器封鎖相機。");
                btnAction.disabled = false;
                btnAction.innerText = "重試";
            }
        }

        // 2. 啟動相機 (使用最穩定的 getUserMedia 方法)
        async function startCamera() {
            const constraints = {
                audio: false,
                video: {
                    // 優先使用後鏡頭，若失敗則使用預設
                    facingMode: 'environment'
                }
            };

            // 這裡使用了標準的 Promise 處理方式
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;

            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
        }

        // 3. AI 偵測迴圈
        async function detectFrame() {
            if (!model) return;

            // 偵測物件
            const predictions = await model.detect(video);
            
            // 繪圖
            renderPredictions(predictions);

            // 持續執行
            requestAnimationFrame(detectFrame);
        }

        // 4. 繪製結果 (修正座標偏移問題)
        function renderPredictions(predictions) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 計算比例，確保框框畫在正確位置
            // 因為 CSS object-fit: cover 會裁切影片，我們需要算出裁切後的偏移量
            const videoRatio = video.videoWidth / video.videoHeight;
            const screenRatio = canvas.width / canvas.height;
            
            let scale, offsetX, offsetY;

            if (screenRatio > videoRatio) {
                // 螢幕比較寬 -> 以寬度為準，上下裁切
                scale = canvas.width / video.videoWidth;
                offsetX = 0;
                offsetY = (canvas.height - (video.videoHeight * scale)) / 2;
            } else {
                // 螢幕比較高 -> 以高度為準，左右裁切
                scale = canvas.height / video.videoHeight;
                offsetX = (canvas.width - (video.videoWidth * scale)) / 2;
                offsetY = 0;
            }

            predictions.forEach(prediction => {
                const [x, y, width, height] = prediction.bbox;
                
                // 轉換座標
                const drawX = x * scale + offsetX;
                const drawY = y * scale + offsetY;
                const drawW = width * scale;
                const drawH = height * scale;

                // 畫框
                ctx.strokeStyle = "#00FF00";
                ctx.lineWidth = 4;
                ctx.strokeRect(drawX, drawY, drawW, drawH);

                // 畫文字標籤
                ctx.fillStyle = "#00FF00";
                ctx.font = "bold 18px Arial";
                ctx.fillText(
                    `${prediction.class} (${Math.round(prediction.score * 100)}%)`,
                    drawX, 
                    drawY > 20 ? drawY - 10 : drawY + 20 // 避免文字跑出畫面頂部
                );
            });
        }

        // 5. 處理視窗縮放
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);

        // 顯示錯誤訊息的輔助函式
        function showError(msg) {
            errorBox.innerHTML = msg;
            errorBox.style.display = 'block';
        }
    </script>
</body>
</html>
