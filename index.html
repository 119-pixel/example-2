<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI æ™ºèƒ½è¦–è¦ºè¾¨è­˜ (TensorFlow.js)</title>
    
    <!-- å¼•å…¥ TensorFlow.js æ ¸å¿ƒèˆ‡æ¨¡å‹ -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

    <style>
        /* --- åŸºç¤è¨­å®š --- */
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden; /* ç¦æ­¢æ²å‹• */
            width: 100vw;
            height: 100vh;
            color: #fff;
        }

        /* --- è¦–è¨Šå±¤ (åº•å±¤) --- */
        #video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: #000;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* è®“ç•«é¢å¡«æ»¿è¢å¹• */
            display: block;
        }

        /* --- ç•«å¸ƒå±¤ (ç¹ªè£½æ¡†æ¡†ç”¨) --- */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ°ä¸‹æ–¹ */
        }

        /* --- UI ä»‹é¢å±¤ (æœ€ä¸Šå±¤) --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* é ‚éƒ¨è³‡è¨Šåˆ— */
        .top-bar {
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        .status-badge {
            background: rgba(0, 255, 204, 0.2);
            border: 1px solid #00ffcc;
            color: #00ffcc;
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .object-count {
            font-size: 14px;
            color: #fff;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        /* åº•éƒ¨æ§åˆ¶åˆ— */
        .bottom-controls {
            padding: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
            pointer-events: auto;
            background: linear-gradient(0deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }

        /* æŒ‰éˆ•æ¨£å¼ */
        .btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        .btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-primary {
            background: #007aff;
            border-color: #007aff;
        }

        /* --- è¼‰å…¥ç•«é¢ --- */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top: 3px solid #00ffcc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .loading-text {
            color: #aaa;
            font-size: 14px;
            margin-top: 10px;
            text-align: center;
            line-height: 1.5;
        }

        #start-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 18px;
            display: none; /* è¼‰å…¥å®Œæˆæ‰é¡¯ç¤º */
        }

    </style>
</head>
<body>

    <!-- è¦–è¨Šèˆ‡ç•«å¸ƒ -->
    <div id="video-container">
        <video id="webcam" playsinline muted autoplay></video>
        <canvas id="canvas"></canvas>
    </div>

    <!-- UI ä»‹é¢ -->
    <div id="ui-layer">
        <div class="top-bar">
            <div class="status-badge" id="status-text">AI ç³»çµ±å¾…æ©Ÿ</div>
            <div class="object-count" id="fps-display">ç‰©ä»¶: 0</div>
        </div>

        <div class="bottom-controls" id="controls" style="display:none;">
            <button class="btn" onclick="togglePause()" id="btn-pause">
                <span>â¸</span> æš«åœ
            </button>
            <button class="btn" onclick="switchCamera()" id="btn-switch">
                <span>ğŸ“·</span> ç¿»è½‰é¡é ­
            </button>
        </div>
    </div>

    <!-- è¼‰å…¥ç•«é¢ -->
    <div id="loading-screen">
        <div class="loader" id="loader"></div>
        <h2 style="font-weight: 300; letter-spacing: 2px;">AI VISION</h2>
        <p class="loading-text" id="loading-msg">æ­£åœ¨åˆå§‹åŒ–é¡ç¥ç¶“ç¶²è·¯...<br>(åˆæ¬¡è¼‰å…¥ç´„éœ€ 10-20 ç§’)</p>
        <button class="btn btn-primary" id="start-btn" onclick="startApp()">å•Ÿå‹•ç³»çµ±</button>
    </div>

    <script>
        // --- è®Šæ•¸å®£å‘Š ---
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loadingMsg = document.getElementById('loading-msg');
        const loader = document.getElementById('loader');
        const startBtn = document.getElementById('start-btn');
        const statusText = document.getElementById('status-text');
        const fpsDisplay = document.getElementById('fps-display');
        const controls = document.getElementById('controls');
        
        let model = null;
        let isDetecting = false;
        let isPaused = false;
        let currentStream = null;
        let facingMode = 'environment'; // é è¨­å¾Œé¡é ­

        // --- 1. åˆå§‹åŒ–æ¨¡å‹ ---
        async function loadModel() {
            try {
                // è¼‰å…¥ COCO-SSD æ¨¡å‹
                // base: 'mobilenet_v2' é€Ÿåº¦è¼ƒå¿«ï¼Œé©åˆæ‰‹æ©Ÿ
                model = await cocoSsd.load({ base: 'mobilenet_v2' });
                
                // æ¨¡å‹è¼‰å…¥å®Œæˆ
                loader.style.display = 'none';
                loadingMsg.innerHTML = "æ¨¡å‹å·²å°±ç·’<br>è«‹å…è¨±ç›¸æ©Ÿæ¬Šé™ä»¥é–‹å§‹";
                startBtn.style.display = 'block';
            } catch (err) {
                console.error(err);
                loadingMsg.innerHTML = "è¼‰å…¥å¤±æ•—<br>è«‹æª¢æŸ¥ç¶²è·¯é€£ç·š";
                loadingMsg.style.color = "#ff3b30";
            }
        }

        // --- 2. å•Ÿå‹•æ‡‰ç”¨ç¨‹å¼ ---
        async function startApp() {
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
            }, 500);

            await setupCamera();
            controls.style.display = 'flex';
        }

        // --- 3. è¨­å®šç›¸æ©Ÿ ---
        async function setupCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                audio: false,
                video: {
                    facingMode: facingMode,
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };

            try {
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        resizeCanvas();
                        if (!isDetecting) {
                            detectFrame();
                        }
                        statusText.innerText = "åµæ¸¬ä¸­";
                        resolve();
                    };
                });
            } catch (err) {
                alert("ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿ: " + err.message);
            }
        }

        // --- 4. èª¿æ•´ Canvas å¤§å° ---
        // é€™æ˜¯ç¢ºä¿ç¹ªåœ–ä½ç½®æ­£ç¢ºçš„é—œéµ
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);

        // --- 5. ç¿»è½‰é¡é ­ ---
        async function switchCamera() {
            facingMode = (facingMode === 'user') ? 'environment' : 'user';
            statusText.innerText = "åˆ‡æ›é¡é ­...";
            await setupCamera();
            statusText.innerText = "åµæ¸¬ä¸­";
        }

        // --- 6. æš«åœ/ç¹¼çºŒ ---
        function togglePause() {
            const btn = document.getElementById('btn-pause');
            if (isPaused) {
                isPaused = false;
                video.play();
                detectFrame();
                btn.innerHTML = '<span>â¸</span> æš«åœ';
                statusText.innerText = "åµæ¸¬ä¸­";
            } else {
                isPaused = true;
                video.pause();
                btn.innerHTML = '<span>â–¶</span> ç¹¼çºŒ';
                statusText.innerText = "å·²æš«åœ";
                statusText.style.color = "yellow";
                statusText.style.borderColor = "yellow";
            }
        }

        // --- 7. æ ¸å¿ƒåµæ¸¬è¿´åœˆ ---
        async function detectFrame() {
            if (isPaused) return;

            isDetecting = true;

            // é€²è¡Œé æ¸¬
            const predictions = await model.detect(video);

            // æ¸…é™¤ç•«å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç¹ªè£½çµæœ
            drawPredictions(predictions);

            // æ›´æ–° UI è¨ˆæ•¸
            fpsDisplay.innerText = `ç‰©ä»¶æ•¸: ${predictions.length}`;
            statusText.style.color = "#00ffcc";
            statusText.style.borderColor = "#00ffcc";

            // ä¸‹ä¸€å¹€
            requestAnimationFrame(detectFrame);
        }

        // --- 8. ç¹ªè£½ç²¾ç¾çš„æ¡†æ¡† ---
        function drawPredictions(predictions) {
            // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ (å› ç‚º video æ˜¯ object-fit: coverï¼Œéœ€è¦è¨ˆç®—å¯¦éš›é¡¯ç¤ºå€åŸŸ)
            const videoRatio = video.videoWidth / video.videoHeight;
            const screenRatio = canvas.width / canvas.height;
            
            let renderWidth, renderHeight, offsetX, offsetY;

            if (screenRatio > videoRatio) {
                // è¢å¹•æ¯”è¼ƒå¯¬ï¼Œä»¥å¯¬åº¦ç‚ºåŸºæº–
                renderWidth = canvas.width;
                renderHeight = canvas.width / videoRatio;
                offsetX = 0;
                offsetY = (canvas.height - renderHeight) / 2;
            } else {
                // è¢å¹•æ¯”è¼ƒé«˜ï¼Œä»¥é«˜åº¦ç‚ºåŸºæº–
                renderHeight = canvas.height;
                renderWidth = canvas.height * videoRatio;
                offsetX = (canvas.width - renderWidth) / 2;
                offsetY = 0;
            }

            const scaleX = renderWidth / video.videoWidth;
            const scaleY = renderHeight / video.videoHeight;

            predictions.forEach(prediction => {
                const [x, y, width, height] = prediction.bbox;
                const className = prediction.class;
                const score = Math.round(prediction.score * 100);

                // è½‰æ›åº§æ¨™åˆ° Canvas
                const drawX = x * scaleX + offsetX;
                const drawY = y * scaleY + offsetY;
                const drawW = width * scaleX;
                const drawH = height * scaleY;

                // è¨­å®šé¡è‰² (ä¾æ“šä¸åŒç‰©ä»¶å¯è¨­å®šä¸åŒè‰²ï¼Œé€™è£¡çµ±ç”¨ç§‘å¹»é’è‰²)
                const color = '#00ffcc';

                // ç•«æ¡†æ¡† (å››å€‹è§’è§’é¢¨æ ¼)
                drawFancyBox(ctx, drawX, drawY, drawW, drawH, color);

                // ç•«æ–‡å­—æ¨™ç±¤èƒŒæ™¯
                ctx.fillStyle = color;
                ctx.font = 'bold 16px "Segoe UI", sans-serif';
                const text = `${className} ${score}%`;
                const textWidth = ctx.measureText(text).width;
                
                ctx.fillRect(drawX, drawY - 25, textWidth + 20, 25);

                // ç•«æ–‡å­—
                ctx.fillStyle = '#000';
                ctx.fillText(text, drawX + 10, drawY - 7);
            });
        }

        // è¼”åŠ©å‡½å¼ï¼šç•«å‡ºåªæœ‰å››å€‹è§’çš„ç§‘å¹»æ¡†æ¡†
        function drawFancyBox(ctx, x, y, w, h, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            const lineLen = Math.min(w, h) * 0.2; // è§’è½ç·šæ¢é•·åº¦

            // å·¦ä¸Š
            ctx.moveTo(x, y + lineLen);
            ctx.lineTo(x, y);
            ctx.lineTo(x + lineLen, y);

            // å³ä¸Š
            ctx.moveTo(x + w - lineLen, y);
            ctx.lineTo(x + w, y);
            ctx.lineTo(x + w, y + lineLen);

            // å³ä¸‹
            ctx.moveTo(x + w, y + h - lineLen);
            ctx.lineTo(x + w, y + h);
            ctx.lineTo(x + w - lineLen, y + h);

            // å·¦ä¸‹
            ctx.moveTo(x + lineLen, y + h);
            ctx.lineTo(x, y + h);
            ctx.lineTo(x, y + h - lineLen);

            ctx.stroke();

            // åŠ ä¸ŠåŠé€æ˜å¡«å……å¢åŠ è­˜åˆ¥åº¦
            ctx.fillStyle = color.replace(')', ', 0.1)').replace('rgb', 'rgba'); // ç°¡å–®çš„ hack
            if(color.startsWith('#')) {
                // å¦‚æœæ˜¯ hexï¼Œä½¿ç”¨å›ºå®šé€æ˜åº¦
                ctx.fillStyle = "rgba(0, 255, 204, 0.1)"; 
            }
            ctx.fillRect(x, y, w, h);
        }

        // é–‹å§‹è¼‰å…¥ç¨‹åº
        window.onload = loadModel;

    </script>
</body>
</html>
